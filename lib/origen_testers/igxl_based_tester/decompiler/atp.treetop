module OrigenTesters
  module IGXLBasedTester
    module Decompiler
      grammar Atp
        include OrigenTesters::Decompiler::BaseGrammar::VectorBased
        include OrigenTesters::IGXLBasedTester::Decompiler::Atp::PlatformTokens

        ### FRONTMATTER ####

        rule frontmatter
          (comment_block / import / variable_assignment / whitespace)* <Frontmatter>
        end

        # Aside: I'm not familar enough with these to know how all these can be used. Only provided starting rules based on what OrigenTesters produces.
        # These may need som updates to be fully compatible with all 3rd party sources. - coreyeng

        rule import
          'import' spacing type:word spacing name:word ';' <Import> {
            def to_ast
              n(:import, type.text_value, name.text_value)
            end
          }
        end

        rule variable_assignment
          var:word spacing? '=' spacing? val:word ';' <VariableAssignment> {
            def to_ast
              n(:variable_assignment, var.text_value, val.text_value)
            end
          }
        end

        ### PIN HEADER ###

        rule pinlist
          'vector' " " '(' '$tset' ', ' pin_names ')' spacing? newline {
            def to_ast
              n(:pinlist, *elements_to_ast)
            end
          }
        end

        rule pin_names
          pin_name? (pin_name_separator pin_name)* { # <PinNames>
            def to_ast
              n(:pin_names, *elements_to_ast)
            end
          }
        end
        
        rule pin_name
          [A-Za-z_0-9]+ { # <PinName>
            def to_ast
              n(:pin_name, self.text_value)
            end
          }
        end

        # This will match pin states and consume the separator EXCEPT for the final separator, if provided.
        # This will allow error detection in the event of extra separators, e.g.: 'X,X,X,' -> 'X,X,X' ','
        rule pin_states
          pin_state? (pin_state_separator pin_state)* <PinStates> {
            def to_ast
              n(:pin_states, *elements_to_ast)
            end
          }
        end
      
        rule pin_state
          [A-Za-z_0-9-]+ <PinState>
        end
      
        rule timeset
          [A-Za-z_0-9]+ '' <Timeset>
        end

        rule pin_state_separator
          ' ' <PinStateSeparator>
        end

        rule pin_name_separator
          ', ' <PinNameSeparator>
        end

        ### VECTORS

        # Listing of available things that may appear in the vector body.
        # We could encounter any one of these.
        rule vector_types
          comment_block / vector / start_label / global_label / label / newline { # <VectorBody>
            def to_ast
              n(:vector_type, *elements_to_ast)
            end
          }
        end

        rule start_label
          'start_label' spacing label_name:label_name ':' spacing? newline { # <StartLabel>
            def to_ast
              n(:start_label, label_name.text_value)
            end
          }
        end

        rule label
          label_name:label_name ':' spacing? label_name? spacing? newline { # <Label>
            def to_ast
              n(:label, label_name.text_value)
            end
          }
        end

        rule label_name
          word {
            def to_ast
              n(:label_name, self.text_value)
            end
          }
        end

        rule global_label
          'global' spacing type:word spacing label_name ':' spacing? newline { # <GlobalLabel>
            def to_ast
              n(:global_label, type.text_value, label_name.text_value)
            end
          }
        end

        rule vector
          (opcode? / (label_name ':')?) spacing opcode_arguments? spacing? '>' spacing timeset spacing pin_states spacing? ';' spacing? comment? newline { # <Vector>
            def to_ast
              n(:vector, *elements_to_ast)
            end
          }
        end

        rule opcode
          [A-Za-z_0-9:]+ { # <Opcode>
            def to_ast
              n(:opcode, self.text_value)
            end
          }
        end

        rule opcode_arguments
          (opcode_argument spacing)+ { # <OpcodeArguments>
            def to_ast
              n(:opcode_arguments, *elements_to_ast)
            end
          }
        end

        rule opcode_argument
          [A-Za-z_0-9()]+ {
            def to_ast
              n(:opcode_argument, self.text_value)
            end
          }
        end

        rule pin_states
          pin_state? (pin_state_separator pin_state)* { # <PinStates>
            def to_ast
              n(:pin_states, *elements_to_ast)
            end
          }
        end
      
        rule pin_state
          [A-Za-z_0-9-]+ { # <PinState>
            def to_ast
              n(:pin_state, self.text_value)
            end
          }
        end
      
        rule timeset
          [A-Za-z_0-9]+ '' { # <Timeset>
            def to_ast
              n(:timeset, self.text_value)
            end
          }
        end

      end
    end
  end
end
