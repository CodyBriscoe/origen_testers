% render "layouts/guides.html" do

Origen provides some basic functionality for reverse-compiling (decompiling)
a pattern source from its text representation (e.g., `.atp` for the J750 platform),
returning an object which can iterate over the available vectors found in the
decompiled pattern.

### Philosophy

The 

### Definitions

### Quickstart

There's no better way to get the feel for the usage of a feature than by just
playing around with it and seeing what happens.

The decompiler contains an option to provide a source from a string. You can
decompile from direct source and get a `OrigenTesters::Decompiler::Pattern` object
from below:

~~~ruby
~~~

You could also copy and paste the text below into a file, say, example.atp, and
give the decompiler this source. More on this in the later sections though:

~~~
~~~

~~~ruby
~~~

`OrigenTesters` is already setup to support the `j750` platform name and the
`.atp` extension. Details on supported platforms 
[are discussed in a differente section.](<%= path 'guides/decompilation/supported' %>)

Running the above will just get you setup to decompiler a pattern. To actually decompile
it, we'll use the `#decompile` method:

~~~ruby
pat.decompiled?
  #=> false

pat.decompile
pat.decompiled?
  #=> true
~~~

<div class="alert alert-info" role="alert">
  Methods <code>OrigenTesters.decompiled_text</code> and <code>OrigenTesters.decompile</code>
  are also available to combine the previous two steps into one.
</div>

With this decompiled pattern, we can start to query its contents. More details
will be discussed [in the API section](<%= path 'guides/decompilation/api' %>)
and is also available [on the OrigenTesters API pages](api)

Below, we'll run through some of the more heavily used methods which originally drove
this feature:

#### Adding Missing Pins

It may be the case that your `DUT` doesn't have the necessary pins in interact with
the decompiled pattern fully. That's easily resolved with a call to `#add_pins`.

`#add_pins` will do just that: adds any pins missing from the pattern source to
the current `DUT` object, returning any pins that were added.

~~~ruby
dut.pins
  #=> []
pat.add_pins

dut.pins
  #=> [:swdio, :swdclk]
pat.add_pins

# New DUT that already contains JTAG pins
dut.pins
  #=> [:tclk, :tdo, :tdi, :tms]
pat.add_pins
  #=> []

# New DUT that has a hodgepodge of SWD and JTAG pins
dut.pins
  #=> [:swdio, :tclk]
pat.add_pins
  #=> [:tdi, :tdo, :tms]
dut.pins
  #=> [:swdio, :tclk, :tdi, :tdo, :tms]
~~~

`#add_pins` will get everything setup for the next phase: executing the pattern.

#### Executing A Pattern Source

With a `Decompiler::Pattern` object, you can call the `#execute` method directly.

`Executing` will iterate though each vector and apply the pin states and repeat
count at each instance. As we saw with collecting the pin states above, our
example pattern devolves to just running each vector and instead applying each
pin state and repeat seqeuentially. In terms of the generic `OrigenTesters` API,
the first few lines of our example source devolves to just:

~~~ruby
# Behind-the-scenes of execution

dut.pin(:tdi).drive()
dut.pin(:tdi).drive()
dut.pin(:tdi).drive()
dut.pin(:tdi).drive()
tester.cycle(65535)

...
~~~

This effectively turns the pattern source into a sequence which can be applied
internally to an Origen application. This could be placed in an application's
`startup` method, for example, to run a sequence for either setup and/or mode
entry without having to decompile it by hand:

~~~ruby
~~~

#### Converting Between Platforms

One additional use case of decompilation is to convert already-compiled sources
between tester platforms. Most vendors provide a means to get a text representation
back from a binary file, then `OrigneTesters` can take over from there.

OrigenTesters provides an elementary `convert` command that, given a source file
and the target platform, will decompile the source in the
[context of the detected platform]()
and output a new platform applicable to the current environment.

~~~
~~~

Run `origen testers:convert -h` for additional options:

~~~
~~~

Conversion is also available on the decompiler:

~~~ruby
~~~

#### Querying Pattern Elements

The above methods are just shortcuts to querying pattern elements and doing something
with the results. If other functionality is needed, or if any of these need to be
overridden for your purposes, the vector elements can be queryied directly:

The pattern is divided into three sections: `frontmatter`, `pinlist`, and `vectors body elements`.

The `frontmatter` contains everything prior to the `pinlist` and the `pinlist`, as
you may guess, contains the pin names. This may also be referred to as the `vector header`
on some platforms.

Both of these are assumed to be small, and are parsed and stored directly in memory:

~~~ruby
# Query the pattern's frontmatter

# Query the pattern's pinlist

# Retrieve the pin names and sizes
~~~

`vector body elements`, on the other hand, is assumed to be a massive section in
the worst case. Consider a scan pattern, which may have 100k+ vectors, for a small
device. Simply put, this is too much for a simple grammar to handle at once and
causes both the runtime, cpu usage, and memory consumption to explode. This may not
be as noticeable on distributed systems, but will be a nightmare, if even possible,
on lower end machines.

To combat this, the `vector body elements` are NOT stored in memory, but are instead
parsed and dealt with only when needed (the exception is the first vector, for reasons
you will see later).

The decompiler takes after Ruby's `enumerable` mixin here, providing an `#each`
method to iterate through the contents of the vectors body.

One important note: the vector body may contain things that ARE NOT vectors, such
as comments, opcodes/instructions, etc. When iterating through the vectors, it
is important to first query what _type_ of element it is before deciding what
to do with it.

Some examples below should help you make sense of this:

~~~ruby
# Iterate through all the vectors, printing the timeset used

# Iterate through all the vectors, printing the comments

# Iterate through all the vectors, printing the pin states.
~~~

This shows a bit of the [VectorBodyElement's API]()
as well.

~~~ruby
is_a_vector?

is_a_comment?

is_platform_specific?
~~~

We've also seen our first look at `platform specifics`. More details are provided
[in this topic's section]().

#### Conclusion

This concludes the quick-start guide. Hopefully you've found enough information
here to get started, but if not:

* See the [API section]()
for additional details on the generic/tester-independent features.
* See the [Platform Specifics section]()
for details on how platform specific elements are handled and what can be done
about them.
* See the [Supported Platforms and Scopes section]()
for details pertaining to what's currently implemented, the limitations
of the decompiler, and supported platforms.
* See the [Adding Platform Support section]()
for instructions to add your own platform or in increase the support for an
existing one.
* See the [YARDOC API]()
for a full API listing, description, and examples.
* Finally, see the various README pages on the [Github repository]()
for a more 'under-to-hood' look at the decompiler.

### Supported Features

As this is still an early feature in its elementary stages, not all vector elements
are supported, and not all valid patterns may decompile. If issues are observed,
please open a ticket and provide:

* An example input that replicates the problem.
* The expected output.
* The output received from the latest <code>OrigenTesters</code> version.

<div class="alert alert-info" role="alert">
  This is still an early feature and not all elements from all platforms are supported quite yet.
  Please see the 
  <a href="<%= path 'guides/decompilation/supported' %>" class="alert-link">supported platforms and scopes page</a>
  for details on what is currently supported.
</div>

% end
